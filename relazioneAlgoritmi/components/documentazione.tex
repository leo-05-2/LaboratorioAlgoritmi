%! Author = leo
%! Date = 16/10/25

% Preamble
\section{Documentazione}
%aggiungere place holder grigio dove poi verrà aggiunta l'immagine dell'uml
\begin{figure}[ht]
  \centering
  \fbox{\rule{0pt}{6cm}\rule{10cm}{0pt}} % altezza 6cm, larghezza 10cm
  \caption{Placeholder: dimensione fissata.}
  \label{fig:fbox}
\end{figure}
\subsection{Struttura del Progetto}
Il progetto è organizzato nelle seguenti componenti principali:

\begin{itemize}
  \item \texttt{src/DataStracture/LinkedList/}: Implementazione della lista concatenata ordinata
  \item \texttt{src/DataStracture/BSTree/}: Implementazione dell'albero binario di ricerca standard
  \item \texttt{src/DataStracture/SBSTree/}: Implementazione dell'albero binario di ricerca con attributo dimensione
  \item \texttt{src/DataGenerator.py}: Generatore di dati casuali per i test
  \item \texttt{src/Tester.py}: Framework per i test di prestazioni
  \item \texttt{src/main.py}: Script principale per l'esecuzione dei test
\end{itemize}
tutti le implementazioni di insert per le strutture dati ricevono in ingresso solo la chiave e creano il nodo a seconda della struttura

\subsection{LinkedList}
La classe \texttt{LinkedList} implementa una lista concatenata ordinata. Gli elementi sono mantenuti in ordine crescente durante l'inserimento.
%aggiungere descrizione dei metodi della linked list no snippet
i metodi principali della linked list senza select e rank:
\texttt{insert(x)}: inserisce l'elemento x nella lista mantenendo l'ordine modificando i puntatori del nodo da inserire e del nodo precedente,
\texttt{delete(x)}: rimuove l'elemento x dalla lista modificando i puntatori del nodo precedente,
\texttt{search(x)}: cerca l'elemento x nella lista e restituisce il nodo se trovato, altrimenti None.

\begin{lstlisting}[language=Python, caption=Implementazione di select() e rank() in LinkedList]
def select(self, k) -> Node or None:
    current = self._root
    count = 1
    while current:
        if count == k:
            return current.data
        current = current.next
        count += 1
    return None  # k troppo grande

def rank(self, x) -> int or None:
    current = self._root
    count = 0
    while current and current.data < x:
        count += 1
        current = current.next
    return count
\end{lstlisting}

In questa implementazione, \texttt{select(k)} scorre linearmente la lista fino a raggiungere l'elemento di posizione k, mentre \texttt{rank(x)} conta gli elementi minori di x.

\subsection{BSTree}
La classe \texttt{BSTree} implementa un albero binario di ricerca standard, senza attributo dimensione nei nodi.
\texttt{insert(x)}: inserisce l'elemento x nell'albero mantenendo la proprietà di ricerca binaria,
\texttt{subtree_size}: calcola la dimensione del sottoalbero avente come radice in un dato nodo,
\texttt{delete(x)}: rimuove l'elemento x dall'albero mantenendo la proprietà di ricerca binaria usando i metodi standard di cancellazione in un BST,
\texttt{search(x)}: cerca l'elemento x nell'albero e restituisce il nodo se trovato, altrimenti None.
\texttt{transplant}: sostituisce un sottoalbero con un altro, utilizzato nella cancellazione dei nodi, ereditato dalla classe astratta.


\begin{lstlisting}[language=Python, caption=Implementazione di select() e rank() in BSTree]
def select(self, k):
    if k is None or k <= 0 or self._root is None:
        return None

    stack = []
    current = self._root
    count = 0

    while stack or current:
        while current:
            stack.append(current)
            current = current.get_left()
        current = stack.pop()
        count += 1
        if count == k:
            return current
        current = current.get_right()

    return None

def rank(self, x):
    current = self._root
    rank = 0
    while current:
        if x > current.get_data():
            left_size = self._subtree_size(current.get_left())
            rank += 1 + left_size
            current = current.get_right()
        else:
            current = current.get_left()
    return rank

def _subtree_size(self, node):
    if node is None:
        return 0
    return 1 + self._subtree_size(node.get_left()) + self._subtree_size(node.get_right())
\end{lstlisting}

In questa implementazione, \texttt{select(k)} effettua una visita in-order iterativa con conteggio degli elementi, mentre \texttt{rank(x)} calcola ricorsivamente la dimensione dei sottoalberi, operazione potenzialmente costosa quando invocata frequentemente.

\subsection{SBSTree}
La classe \texttt{SBSTree} implementa un albero binario di ricerca dove ogni nodo mantiene la dimensione del suo sottoalbero.
\texttt{insert(x)}: inserisce l'elemento x nell'albero mantenendo la proprietà di ricerca binaria e aggiornando l'attributo dimensione dei nodi lungo il percorso di inserimento,
\texttt{delete(x)}: rimuove l'elemento x dall'albero mantenendo la proprietà di ricerca binaria e aggiornando l'attributo dimensione dei nodi lungo il percorso di cancellazione,
\texttt{search(x)}: cerca l'elemento x nell'albero e restituisce il nodo se trovato, altrimenti None.
\texttt{update_size_upwards}: aggiorna l'attributo dimensione dei nodi lungo il percorso dalla radice al nodo specificato.
\texttt{transplant}: sostituisce un sottoalbero con un altro, utilizzato nella cancellazione dei nodi, ereditato dalla classe astratta.

\begin{lstlisting}[language=Python, caption=Implementazione di select() e rank() in SBSTree]
def select(self, k):
    return self._select(self._root, k)

def _select(self, node, k):
    if node is None:
        return None
    left_size = node.get_left().get_size() if node.get_left() else 0
    if k == left_size + 1:
        return node
    elif k <= left_size:
        return self._select(node.get_left(), k)
    else:
        return self._select(node.get_right(), k - left_size - 1)

def rank(self, x):
    return self._rank(self._root, x)

def _rank(self, node, x):
    if node is None:
        return 0
    if x < node.get_data():
        return self._rank(node.get_left(), x)
    elif x > node.get_data():
        left_size = node.get_left().get_size() if node.get_left() else 0
        return 1 + left_size + self._rank(node.get_right(), x)
    else:
        left_size = node.get_left().get_size() if node.get_left() else 0
        return left_size
\end{lstlisting}

In questa implementazione, sia \texttt{select(k)} che \texttt{rank(x)} usano la proprietà \texttt{size} di ogni nodo per determinare rapidamente la dimensione dei sottoalberi, consentendo operazioni più efficienti.

\subsection{Funzioni di Test}
Il framework di test è stato progettato per valutare rigorosamente le prestazioni delle diverse implementazioni:

\begin{itemize}
  \item \textbf{Generazione dati}: Ogni test genera dataset di dimensione crescente
  \item \textbf{Warm-up}: Prima delle misurazioni vengono effettuate chiamate di warm-up per stabilizzare la cache e ridurre l'overhead iniziale
  \item \textbf{Campionamento}: Per ogni dataset vengono estratti casualmente indici k da testare
  \item \textbf{Ripetizioni}: Ogni operazione viene ripetuta più volte per ridurre il rumore di misurazione
  \item \textbf{Statistiche}: I risultati sono aggregati calcolando media e deviazione standard dei tempi
\end{itemize}
% è fatta con numpy
\texttt{Datagenerator.py} genera liste di numeri casuali unici per i test, il metodo \textbf{start} restituisce un array numpy di numeri casuali senza ripetizioni di dimensione specificata.
\subsubsection{Tester}
%TODO: aggiungere descrizione cosnippet e spiegare i metodi principali

