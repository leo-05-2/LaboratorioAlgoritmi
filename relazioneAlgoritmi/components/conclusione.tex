%! Author = leo
%! Date = 16/10/25

% Preamble
\section{Conclusione}
In questa relazione abbiamo confrontato le prestazioni pratiche di tre implementazioni per le statistiche d'ordine dinamico: \texttt{LinkedList}, \texttt{BSTree} (albero binario non bilanciato senza campo \texttt{size}) e \texttt{SBStree} (albero che mantiene il campo \texttt{size}).

Riepilogo dei risultati:
\begin{itemize}
  \item \textbf{SBStree} fornisce le migliori prestazioni per entrambe le operazioni \texttt{select} e \texttt{rank} nelle misure presentate, con crescita logaritmica apparente e varianza contenuta.
  \item \textbf{BSTree} (non bilanciato e senza campo \texttt{size}) mostra ampia variabilità specialmente per \texttt{rank}, dovuta alla possibile degenerazione della forma dell'albero; i tempi possono variare molto tra istanze diverse.
  \item \textbf{LinkedList} ha comportamento prevedibile (linearità per select/rank) ma non è competitiva su grandi dimensioni rispetto alla struttura con \texttt{size}.
\end{itemize}

\subsection{conclusione test 1}
\textbf{Conclusione Test 1}:come evidenziato da \ref{tab:random} Anche in uno scenario medio con dati casuali, l'assenza dell'attributo \texttt{size} rende il \texttt{BSTree} inefficiente quanto una \texttt{LinkedList}. L'\texttt{SBSTree} è di gran lunga la soluzione più performante.


\subsection{conclusione 2}
\textbf{Conclusione Test 2}: Questo test evidenzia la non importanza del bilanciamento se manca l'attributo size, in quanto i risultati sono simili ai precedenti, se l'albero binario avesse avuto size sarebbe stato influenzato dai dati. L'\texttt{SBSTree} è robusto rispetto all'ordine di inserimento dei dati, garantendo prestazioni efficienti e prevedibili in ogni scenario.

\textbf{Conclusione}: Anche se l'albero fosse perfettamente bilanciato ($h = O(\log n)$), l'assenza di informazioni pre-calcolate sulla dimensione dei sottoalberi costringe l'algoritmo a visitare/contare elementi, rendendo il costo \textbf{$O(n)$} indipendentemente dal bilanciamento.
mentre se vi fossero informazioni pre calcolate il costo dipenderebbe anche per bst dall' altezza diventando soggetto all' ordine dei dati, ma non essendo autobilanciato risulterebbe meno stabile di sbs
\\
\paragraph{Analisi delle Pendenze}
Analisi delle Pendenze (O(n)): LinkedList vs. BSTree
\\
\\
\noindent\makebox[\textwidth][c]{%
  \begin{minipage}{0.7\textwidth}\centering
    \includegraphics[width=\linewidth]{../src/png/rank_performance_LinkedList_BSTree_random}
    \captionof{figure}{Rank performance (overview)}\label{fig:rank_performance_overview_tr}
  \end{minipage}%
  \begin{minipage}{0.7\textwidth}\centering
    \includegraphics[width=\linewidth]{../src/png/select_performance_LinkedList_BSTree_random}
    \captionof{figure}{Rank performance (overview)}\label{fig:rank_performance_overview}
  \end{minipage}%
}\\\\
\begin{itemize}
  \item \textbf{Per select(k):}
    \begin{itemize}
      \item Il grafico mostra che \texttt{BSTree} ha una pendenza significativamente maggiore (più ripida) rispetto a \texttt{LinkedList}; entrambe hanno complessità media $O(n)$ ma con costanti diverse.
      \item \texttt{LinkedList} esegue una semplice scansione sequenziale (\texttt{current = current.next}), operazione molto efficiente a basso livello.
      \item \texttt{BSTree} richiede una visita in-order (iterativa o ricorsiva) che implica la gestione di uno stack e l'attraversamento dei puntatori \texttt{left}/\texttt{right}, comportando un ``maggiore overhead per nodo visitato''.
    \end{itemize}

  \item \textbf{Per rank(x):}
    \begin{itemize}
      \item I grafici mostrano pendenze molto simili per le due strutture: l'analisi teorica lo anticipa, notando che i ``coefficienti [sono] simili''.
      \item \texttt{LinkedList} esegue una scansione lineare contando i nodi (costo $O(n)$).
      \item \texttt{BSTree} esegue discesa e invoca funzioni di conteggio sui sottoalberi (ad es. \texttt{\_subtree\_size}); nonostante le chiamate ricorsive, il numero totale di nodi visitati risulta ``comparabile'' a quello della scansione lineare.
    \end{itemize}
\end{itemize}

In sintesi, i test confermano che per \texttt{select} la scansione della lista ha costanti molto favorevoli rispetto alla visita in-order dell'albero, mentre per \texttt{rank} i costi totali risultano comparabili tra le due strutture.


\textit{Nota sul confronto con LinkedList}: Sebbene entrambe le strutture abbiano complessità $O(n)$ nel caso medio, il \textbf{coefficiente costante è significativamente diverso per select}. La LinkedList ha costo reale $\Theta(k)$ (scorre esattamente $k$ nodi in sequenza), mentre BSTree con visita in-order deve attraversare la struttura ad albero seguendo puntatori left/right con maggiore overhead per nodo visitato. Nei test empirici, la retta di crescita di BSTree per \texttt{select} risulta \textbf{più ripida} rispetto a LinkedList, mentre per \texttt{rank} le due strutture mostrano pendenze simili.

% nparagraph per l'ambientte di svilupp sia hardware che software
\subsection{Ambiente di Sviluppo}
I test sono stati eseguiti in un ambiente di sviluppo controllato per garantire la riproducibilità e l'affidabilità dei risultati. Di seguito sono riportati i dettagli dell'ambiente hardware e software utilizzato:
\begin{itemize}
  \item \textbf{Hardware:}
    \begin{itemize}
      \item Processore: Intel Core i7-8565U × 8
      \item RAM: 8GB DDR4
      \item Sistema Operativo: Ubuntu 24.04.3 LTS con Kernel Linux 6.8.0-85-generic
    \end{itemize}
  \end {itemize}
per l'ambiente si è usato conda e come ide pycharm, per l'UML si è usato starUML, per la relazione si è usata un' estensione di pycharm per latex.
