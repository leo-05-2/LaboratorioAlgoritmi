%! Author = leo
%! Date = 16/10/25

% Preamble
\section{Conclusione}
In questa relazione abbiamo confrontato le prestazioni pratiche di tre implementazioni per le statistiche d'ordine dinamico: \texttt{LinkedList}, \texttt{BSTree} (albero binario non bilanciato senza campo \texttt{size}) e \texttt{SBStree} (albero che mantiene il campo \texttt{size}).

Riepilogo dei risultati:
\begin{itemize}
  \item \textbf{SBStree} fornisce le migliori prestazioni per entrambe le operazioni \texttt{select} e \texttt{rank} nelle misure presentate, con crescita logaritmica apparente e varianza contenuta.
  \item \textbf{BSTree} (non bilanciato e senza campo \texttt{size}) mostra ampia variabilità specialmente per \texttt{rank}, dovuta alla possibile degenerazione della forma dell'albero; i tempi possono variare molto tra istanze diverse.
  \item \textbf{LinkedList} ha comportamento prevedibile (linearità per select/rank) ma non è competitiva su grandi dimensioni rispetto alla struttura con \texttt{size}.
\end{itemize}

Osservazioni sperimentali e raccomandazioni:
\begin{itemize}
  \item Le misure sono state condotte con warm-up e campionamento multiplo per ridurre bias; tuttavia valori estremamente piccoli (microsecondi) sono sensibili a jitter di sistema. Aumentare \texttt{datasets\_per\_n}, \texttt{count} o \texttt{calls\_per\_test} migliora la stabilit\`a statistica a costo di tempo computazionale.
  \item Per analisi future consigliamo di introdurre anche strutture bilanciate come AVL/Red-Black con campo \texttt{size} per confronti più completi e di misurare anche l'overhead di inserimento/rimozione associato al mantenimento del campo \texttt{size}.
\end{itemize}
%aggiungere grafici
\begin{figure}[ht]
  \centering
  \fbox{\rule{0pt}{6cm}\rule{10cm}{0pt}} % altezza 6cm, larghezza 10cm
  \caption{Placeholder: dimensione fissata.}
  \label{fig:fbox}
\end{figure}
Conclusione pratica: per applicazioni che richiedono \texttt{select} e \texttt{rank} efficienti su insiemi dinamici, l'uso di una struttura che mantiene \texttt{size} nei nodi (come \texttt{SBStree}) risulta consigliabile; alberi non bilanciati senza informazione di size mostrano prestazioni incerte e variabili.


\subsubsection{test empirici}
% Sostituito paragrafo con elenco puntato per migliorare leggibilità nel PDF
I test empirici condotti confermano in modo netto le previsioni della complessità teorica, evidenziando le profonde differenze prestazionali tra le tre strutture dati analizzate per le statistiche d'ordine dinamico.

\begin{itemize}
  \item \textbf{Supremazia di SBSTree (AVL + \texttt{size}):} I risultati per SBSTree sono consistenti e mostrano tempi di esecuzione per \texttt{select} e \texttt{rank} vicini alla complessità logaritmica, ossia \(O(\log n)\). Questo comportamento è dovuto al bilanciamento AVL, che garantisce un'altezza \(h=O(\log n)\), e all'attributo \texttt{size} nei nodi, che permette di prendere decisioni in tempo \(O(1)\) ad ogni passo della discesa senza dover visitare interi sottoalberi.

  \item \textbf{Inefficienza di BSTree (senza \texttt{size}):} I test mostrano che un albero binario di ricerca non dotato del campo \texttt{size}, anche se mediamente bilanciato su dati casuali, non è efficiente per le statistiche d'ordine dinamico. In assenza di \texttt{size} le operazioni \texttt{select} e \texttt{rank} richiedono di conteggiare nodi o di eseguire visite in-order sui sottoalberi, portando a costi complessivi dell'ordine di \(O(n)\) in molti casi e annullando il vantaggio teorico dell'altezza \(O(\log n)\) per semplici ricerche.

  \item \textbf{Linearità di LinkedList:} La lista concatenata ordinata mostra il comportamento atteso: sia \texttt{select} che \texttt{rank} hanno costo lineare \(O(n)\), essendo necessaria una scansione sequenziale della struttura.
\end{itemize}


\subsubsection{Analisi delle Pendenze}
Analisi delle Pendenze (O(n)): LinkedList vs. BSTree

\begin{itemize}
  \item \textbf{Per select(k):}
    \begin{itemize}
      \item Il grafico mostra che \texttt{BSTree} ha una pendenza significativamente maggiore (più ripida) rispetto a \texttt{LinkedList}; entrambe hanno complessità media $O(n)$ ma con costanti diverse.
      \item \texttt{LinkedList} esegue una semplice scansione sequenziale (\texttt{current = current.next}), operazione molto efficiente a basso livello.
      \item \texttt{BSTree} richiede una visita in-order (iterativa o ricorsiva) che implica la gestione di uno stack e l'attraversamento dei puntatori \texttt{left}/\texttt{right}, comportando un ``maggiore overhead per nodo visitato''.
    \end{itemize}

  \item \textbf{Per rank(x):}
    \begin{itemize}
      \item I grafici mostrano pendenze molto simili per le due strutture: l'analisi teorica lo anticipa, notando che i ``coefficienti [sono] simili''.
      \item \texttt{LinkedList} esegue una scansione lineare contando i nodi (costo $O(n)$).
      \item \texttt{BSTree} esegue discesa e invoca funzioni di conteggio sui sottoalberi (ad es. \texttt{\_subtree\_size}); nonostante le chiamate ricorsive, il numero totale di nodi visitati risulta ``comparabile'' a quello della scansione lineare.
    \end{itemize}
\end{itemize}

In sintesi, i test confermano che per \texttt{select} la scansione della lista ha costanti molto favorevoli rispetto alla visita in-order dell'albero, mentre per \texttt{rank} i costi totali risultano comparabili tra le due strutture.
