%! Author = leo
%! Date = 16/10/25

% Preamble
\section{Conclusione}
In questa relazione sono state confrontate le prestazioni pratiche di tre implementazioni per le statistiche d'ordine dinamiche: \texttt{LinkedList}, \texttt{BSTree} (albero binario non bilanciato senza campo \texttt{size}) e \texttt{SBStree} (albero AVL che mantiene il campo \texttt{size}).

Riepilogo dei risultati:
\begin{itemize}
  \item \textbf{SBStree} fornisce le migliori prestazioni per entrambe le operazioni \texttt{select} e \texttt{rank} nelle misure presentate, con crescita logaritmica apparente e varianza contenuta.
  \item \textbf{BSTree} (non bilanciato e senza campo \texttt{size}) mostra ampia variabilità specialmente per \texttt{rank}; i tempi possono variare molto tra istanze diverse, non dipendono dall' altezza.
  \item \textbf{LinkedList} ha comportamento prevedibile (linearità per select/rank) ma non è competitiva su grandi dimensioni rispetto alla struttura con \texttt{size}.
\end{itemize}

\subsection{Conclusione test 1}
\textbf{Conclusione Test 1}:viene rispettata l'attesa teorica come evidenziato da \ref{tab:random} Anche in uno scenario medio con dati casuali, l'assenza dell'attributo \texttt{size} rende il \texttt{BSTree} inefficiente quanto una \texttt{LinkedList}. L'\texttt{SBSTree} è di gran lunga la soluzione più performante.


\subsection{Conclusione 2}
\textbf{Conclusione Test 2}: Questo test evidenzia la non importanza del bilanciamento se manca l'attributo size, in quanto i risultati sono simili ai precedenti; anche se l'albero fosse perfettamente bilanciato ($h = O(\log n)$), l'assenza di informazioni pre-calcolate sulla dimensione dei sottoalberi costringe l'algoritmo a visitare/contare elementi, rendendo il costo \textbf{$O(n)$} indipendentemente dal bilanciamento
mentre, se vi fossero informazioni pre calcolate, il costo dipenderebbe anche per \textbf{BSTree} dall' altezza diventando soggetto all' ordine dei dati, ma non essendo autobilanciato risulterebbe meno stabile di \textbf{SBSTree}.
\\
\paragraph{Analisi delle Pendenze}
Analisi delle Pendenze (O(n)): LinkedList vs. BSTree
\\
\\
\begin{figure}[H]
  \centering
\begin{minipage}{\textwidth}\centering
  \includegraphics[width=\linewidth]{./resource/png/rank_performance_LinkedList_BSTree_random}
  \captionof{figure}{Rank performance (overview)}\label{fig:rank_performance_overview_tr}
\end{minipage}%
  \end{figure}
\begin{figure}[H]
  \centering
\begin{minipage}{\textwidth}\centering
  \includegraphics[width=\linewidth]{./resource/png/select_performance_LinkedList_BSTree_random}
  \captionof{figure}{Rank performance (overview)}\label{fig:rank_performance_overview}
\end{minipage}%
\end{figure}

\\\\
\begin{itemize}
  \item \textbf{Per select(k):}
    \begin{itemize}
      \item Il grafico mostra che \texttt{BSTree} ha una pendenza significativamente maggiore (più ripida) rispetto a \texttt{LinkedList}; entrambe hanno complessità media $O(n)$ ma con costanti diverse.
      \item \texttt{LinkedList} esegue una semplice scansione sequenziale (\texttt{current = current.next}), operazione molto efficiente a basso livello.
      \item \texttt{BSTree} richiede una visita in-order (iterativa o ricorsiva) che implica la gestione di uno stack e l'attraversamento dei puntatori \texttt{left}/\texttt{right}, comportando un maggiore overhead per nodo visitato.
    \end{itemize}

  \item \textbf{Per rank(x):}
    \begin{itemize}
      \item I grafici mostrano pendenze molto simili per le due strutture.
      \item \texttt{LinkedList} esegue una scansione lineare contando i nodi (costo $O(n)$).
      \item \texttt{BSTree} esegue discesa e invoca funzioni di conteggio sui sottoalberi (ad es. \texttt{\_subtree\_size}); nonostante le chiamate ricorsive, il numero totale di nodi visitati risulta ``comparabile'' a quello della scansione lineare.
    \end{itemize}
\end{itemize}

In sintesi, i test confermano che per \texttt{select} la scansione della lista ha costanti molto favorevoli rispetto alla visita in-order dell'albero, mentre per \texttt{rank} i costi totali risultano comparabili tra le due strutture.

% nparagraph per l'ambientte di svilupp sia hardware che software
\subsection{Ambiente di Sviluppo}
I test sono stati eseguiti in un ambiente di sviluppo controllato per garantire la riproducibilità e l'affidabilità dei risultati. Di seguito sono riportati i dettagli dell'ambiente hardware e software utilizzato:
\begin{itemize}
  \item \textbf{Hardware:}
    \begin{itemize}
      \item Processore: Intel Core i7-8565U × 8
      \item RAM: 8GB DDR4
      \item Sistema Operativo: Ubuntu 24.04.3 LTS con Kernel Linux 6.8.0-85-generic
    \end{itemize}
  \end {itemize}
per l'ambiente si è usato Anaconda in modo da avere già i moduli più necessari come numpy e matplotlib e per aver già tutto pronto per l’esecuzione del codice sulla piattaforma PythonAnywhere;
come ide pycharm, per l'UML si è usato starUML, per la relazione si è usata un' estensione di pycharm per latex: TeXiFy IDEA.
